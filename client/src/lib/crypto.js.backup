// client/src/lib/crypto.js
// Utility functions for end‚Äëto‚Äëend encryption in the chat app.
// Uses Web Crypto API (available in modern browsers).

const TEXT_ENCODER = new TextEncoder();
const TEXT_DECODER = new TextDecoder();

// ---------------------------------------------------------------------------
// 1Ô∏è‚É£ Key pair handling (RSA‚ÄëOAEP, 2048‚Äëbit)
// ---------------------------------------------------------------------------
export async function ensureKeyPair() {
    // Check if keys are already stored in localStorage.
    const storedPub = localStorage.getItem('chatapp_public_key_pem');
    const storedPriv = localStorage.getItem('chatapp_private_key_jwk');
    if (storedPub && storedPriv) {
        return { publicKeyPem: storedPub, privateKeyJwk: JSON.parse(storedPriv) };
    }
    // Generate a fresh RSA‚ÄëOAEP key pair.
    const keyPair = await crypto.subtle.generateKey(
        {
            name: 'RSA-OAEP',
            modulusLength: 2048,
            publicExponent: new Uint8Array([1, 0, 1]),
            hash: 'SHA-256'
        },
        true,
        ['encrypt', 'decrypt']
    );
    // Export public key as PEM for sending to the server.
    const spki = await crypto.subtle.exportKey('spki', keyPair.publicKey);
    const publicPem = spkiToPem(new Uint8Array(spki));
    // Export private key as JWK for local storage.
    const privateJwk = await crypto.subtle.exportKey('jwk', keyPair.privateKey);
    localStorage.setItem('chatapp_public_key_pem', publicPem);
    localStorage.setItem('chatapp_private_key_jwk', JSON.stringify(privateJwk));
    return { publicKeyPem: publicPem, privateKeyJwk: privateJwk };
}

export async function importPublicKeyFromPem(pem) {
    const b64 = pem.replace('-----BEGIN PUBLIC KEY-----', '')
        .replace('-----END PUBLIC KEY-----', '')
        .replace(/\s+/g, '');
    const der = Uint8Array.from(atob(b64), c => c.charCodeAt(0)).buffer;
    return await crypto.subtle.importKey('spki', der, { name: 'RSA-OAEP', hash: 'SHA-256' }, true, ['encrypt']);
}

export async function importPrivateKeyFromJwk(jwk) {
    return await crypto.subtle.importKey('jwk', jwk, { name: 'RSA-OAEP', hash: 'SHA-256' }, false, ['decrypt']);
}

// ---------------------------------------------------------------------------
// 2Ô∏è‚É£ Session key derivation (deterministic, based on both usernames)
// ---------------------------------------------------------------------------
export async function getSessionKey(userA, userB) {
    // Create a deterministic 256‚Äëbit key from the two usernames (order‚Äëindependent).
    const sorted = [userA, userB].sort().join(':');
    const hashBuf = await crypto.subtle.digest('SHA-256', TEXT_ENCODER.encode(sorted));
    return new Uint8Array(hashBuf); // 32‚Äëbyte raw key material
}

// ---------------------------------------------------------------------------
// 3Ô∏è‚É£ Per‚Äëmessage key derivation (HMAC‚ÄëSHA‚Äë256) and AES‚ÄëGCM helpers
// ---------------------------------------------------------------------------
export async function deriveMessageKey(sessionKeyRaw, msgNo) {
    // HMAC‚ÄëSHA‚Äë256 over the message number (as string) using the session key.
    const msgNoBytes = TEXT_ENCODER.encode(String(msgNo));
    const hmacKey = await crypto.subtle.importKey(
        'raw',
        sessionKeyRaw,
        { name: 'HMAC', hash: 'SHA-256' },
        false,
        ['sign']
    );
    const signature = await crypto.subtle.sign('HMAC', hmacKey, msgNoBytes);
    // Use the first 32 bytes as an AES‚ÄëGCM key.
    const aesKey = await crypto.subtle.importKey(
        'raw',
        signature.slice(0, 32),
        { name: 'AES-GCM', length: 256 },
        false,
        ['encrypt', 'decrypt']
    );
    return aesKey;
}

export async function encryptMessage(sessionKeyRaw, msgNo, plaintext) {
    const aesKey = await deriveMessageKey(sessionKeyRaw, msgNo);
    const iv = crypto.getRandomValues(new Uint8Array(12)); // 96‚Äëbit IV for GCM
    const data = TEXT_ENCODER.encode(plaintext);
    const cipherBuf = await crypto.subtle.encrypt({ name: 'AES-GCM', iv }, aesKey, data);
    // Concatenate IV + ciphertext and base64‚Äëencode for transport.
    const combined = new Uint8Array(iv.length + cipherBuf.byteLength);
    combined.set(iv, 0);
    combined.set(new Uint8Array(cipherBuf), iv.length);
    return arrayBufferToBase64(combined.buffer);
}

export async function decryptMessage(sessionKeyRaw, msgNo, base64Cipher) {
    const aesKey = await deriveMessageKey(sessionKeyRaw, msgNo);
    const combined = base64ToUint8Array(base64Cipher);
    const iv = combined.slice(0, 12);
    const cipher = combined.slice(12);
    const plainBuf = await crypto.subtle.decrypt({ name: 'AES-GCM', iv }, aesKey, cipher);
    return TEXT_DECODER.decode(plainBuf);
}

// ---------------------------------------------------------------------------
// Helper utilities (PEM conversion, base64 helpers)
// ---------------------------------------------------------------------------
function spkiToPem(spkiBytes) {
    const b64 = btoa(String.fromCharCode(...spkiBytes));
    const wrapped = b64.match(/.{1,64}/g).join('\n');
    return `-----BEGIN PUBLIC KEY-----\n${wrapped}\n-----END PUBLIC KEY-----`;
}

function arrayBufferToBase64(buf) {
    const bytes = new Uint8Array(buf);
    let binary = '';
    for (let i = 0; i < bytes.length; i++) binary += String.fromCharCode(bytes[i]);
    return btoa(binary);
}

function base64ToUint8Array(base64) {
    const binary = atob(base64);
    const bytes = new Uint8Array(binary.length);
    for (let i = 0; i < binary.length; i++) bytes[i] = binary.charCodeAt(i);
    return bytes; // FIX: Was missing return statement!
}

// ---------------------------------------------------------------------------
// 4Ô∏è‚É£ ECDSA Digital Signatures (P-256 curve) for Message Verification
// ---------------------------------------------------------------------------

/**
 * Generate ECDSA P-256 key pair for signing messages.
 * Separate from encryption keys for security best practices.
 * @returns {Promise<{publicKey: CryptoKey, privateKey: CryptoKey}>}
 */
export async function generateSigningKeyPair() {
    const keyPair = await crypto.subtle.generateKey(
        {
            name: 'ECDSA',
            namedCurve: 'P-256' // NIST P-256 curve (secp256r1)
        },
        true, // extractable
        ['sign', 'verify']
    );
    return keyPair;
}

/**
 * Export ECDSA public key to PEM format for server storage.
 * @param {CryptoKey} publicKey - ECDSA public key
 * @returns {Promise<string>} PEM-encoded public key
 */
export async function exportSigningPublicKey(publicKey) {
    const spki = await crypto.subtle.exportKey('spki', publicKey);
    return spkiToPem(new Uint8Array(spki));
}

/**
 * Export ECDSA private key to JWK for local storage.
 * @param {CryptoKey} privateKey - ECDSA private key
 * @returns {Promise<object>} JWK object
 */
export async function exportSigningPrivateKey(privateKey) {
    return await crypto.subtle.exportKey('jwk', privateKey);
}

/**
 * Import ECDSA public key from PEM format.
 * @param {string} pem - PEM-encoded public key
 * @returns {Promise<CryptoKey>} ECDSA public key
 */
export async function importSigningPublicKey(pem) {
    const b64 = pem.replace('-----BEGIN PUBLIC KEY-----', '')
        .replace('-----END PUBLIC KEY-----', '')
        .replace(/\s+/g, '');
    const der = Uint8Array.from(atob(b64), c => c.charCodeAt(0)).buffer;
    return await crypto.subtle.importKey(
        'spki',
        der,
        { name: 'ECDSA', namedCurve: 'P-256' },
        true,
        ['verify']
    );
}

/**
 * Import ECDSA private key from JWK.
 * @param {object} jwk - JWK object
 * @returns {Promise<CryptoKey>} ECDSA private key
 */
export async function importSigningPrivateKey(jwk) {
    return await crypto.subtle.importKey(
        'jwk',
        jwk,
        { name: 'ECDSA', namedCurve: 'P-256' },
        false,
        ['sign']
    );
}

/**
 * Sign a message with ECDSA private key.
 * Creates a digital signature to prove authenticity and detect tampering.
 * @param {CryptoKey} privateKey - ECDSA private key
 * @param {string} message - Message to sign (usually encrypted content)
 * @returns {Promise<string>} Base64-encoded signature
 */
export async function signMessage(privateKey, message) {
    const messageBytes = TEXT_ENCODER.encode(message);
    const signatureBuffer = await crypto.subtle.sign(
        {
            name: 'ECDSA',
            hash: 'SHA-256'
        },
        privateKey,
        messageBytes
    );
    return arrayBufferToBase64(signatureBuffer);
}

/**
 * Verify message signature with ECDSA public key.
 * Returns true if signature is valid, false if tampered or forged.
 * @param {CryptoKey} publicKey - ECDSA public key of sender
 * @param {string} message - Original message (encrypted content)
 * @param {string} signatureBase64 - Base64-encoded signature
 * @returns {Promise<boolean>} True if signature is valid
 */
export async function verifySignature(publicKey, message, signatureBase64) {
    try {
        if (!signatureBase64 || !message || !publicKey) {
            console.warn('Missing required parameters for signature verification');
            return false;
        }

        const messageBytes = TEXT_ENCODER.encode(message);
        const signatureBytes = base64ToUint8Array(signatureBase64);

        if (!signatureBytes || signatureBytes.length === 0) {
            console.warn('Invalid signature bytes');
            return false;
        }

        const isValid = await crypto.subtle.verify(
            {
                name: 'ECDSA',
                hash: 'SHA-256'
            },
            publicKey,
            signatureBytes.buffer, // Use .buffer to get ArrayBuffer
            messageBytes
        );
        return isValid;
    } catch (error) {
        console.error('Signature verification error:', error);
        return false;
    }
}

/**
 * Ensure signing key pair exists in localStorage.
 * Generates new keys if not found.
 * @returns {Promise<{publicKeyPem: string, privateKeyJwk: object}>}
 */
export async function ensureSigningKeyPair() {
    const storedPub = localStorage.getItem('chatapp_signing_public_key_pem');
    const storedPriv = localStorage.getItem('chatapp_signing_private_key_jwk');

    if (storedPub && storedPriv) {
        return {
            publicKeyPem: storedPub,
            privateKeyJwk: JSON.parse(storedPriv)
        };
    }

    // Generate new signing key pair
    const keyPair = await generateSigningKeyPair();
    const publicPem = await exportSigningPublicKey(keyPair.publicKey);
    const privateJwk = await exportSigningPrivateKey(keyPair.privateKey);

    localStorage.setItem('chatapp_signing_public_key_pem', publicPem);
    localStorage.setItem('chatapp_signing_private_key_jwk', JSON.stringify(privateJwk));

    return {
        encrypted
    );
        return new Uint8Array(decrypted);
    }

    /**
     * Generate realistic dummy messages for decoy mode
     * @param {string} userA - First user
     * @param {string} userB - Second user
     * @param {number} count - Number of messages to generate
     * @returns {Array} Array of dummy message objects
     */
    export function generateDummyMessages(userA, userB, count = 20) {
        const templates = [
            "Hey, how are you?",
            "Good, thanks! You?",
            "Meeting at {time} confirmed",
            "Ok üëç",
            "See you tomorrow",
            "Thanks for the update",
            "Got it",
            "Sounds good",
            "Let me know when you're free",
            "Sure, will do",
            "How's the project going?",
            "Making progress, almost done",
            "Great!",
            "Can we reschedule?",
            "Yes, how about {day}?",
            "Perfect",
            "Sent you the file",
            "Received, thanks!",
            "No problem",
            "Talk later",
            "Have a good day!",
            "You too!",
            "Let's catch up soon",
            "Definitely",
            "Working on it now",
            "Keep me posted",
            "Will do",
            "Thanks again",
            "Anytime!",
            "See you then"
        ];

        const times = ['3 PM', '5 PM', '6 PM', '10 AM', '2 PM', '4:30 PM'];
        const days = ['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday'];

        const dummyMessages = [];
        const now = Date.now();
        const hourInMs = 3600000;

        for (let i = 0; i < count; i++) {
            const template = templates[Math.floor(Math.random() * templates.length)];
            const message = template
                .replace('{time}', times[Math.floor(Math.random() * times.length)])
                .replace('{day}', days[Math.floor(Math.random() * days.length)]);

            // Alternate sender/receiver
            const sender = i % 2 === 0 ? userA : userB;
            const receiver = i % 2 === 0 ? userB : userA;

            dummyMessages.push({
                id: `dummy_${i}`,
                sender,
                receiver,
                message,
                content: message,
                timestamp: new Date(now - (count - i) * hourInMs * (1 + Math.random())),
                verified: true,  // Make it look legitimate
                isDummy: true    // Internal flag (not shown to attacker)
            });
        }

        return dummyMessages;
    }
